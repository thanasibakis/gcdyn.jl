#!/usr/bin/env julia

# Activate the "examples" Julia project from the nextflow work folder
# One day I'll find a prettier way to do this
import Pkg; Pkg.activate("../../../..")

using gcdyn, JLD2
import JSON

# Shorthand for extracting node data from the JSON `nodes` objects
get_node_data(json_tree, node_name, field) = filter(d -> d["name"] == node_name, json_tree["nodes"])[1][field]

# Methods named `↓` are used to parse Newick into TreeNode objects.
# Inspired by https://www.jamesporter.me/2013/11/27/how-to-succeed-at-parsing.html
# Requires that node labels exist only on leaves and are integers

# Create a leaf node. We will have to fill in the state and adjust `t` to be `length + up.length`
↓(name::Int, length::Real) = TreeNode(name, :sampled_survival, length, -1, [])

# Create an ancestral node. We will have to fill in the name and state and adjust `t`
↓(children::Tuple{TreeNode, TreeNode}, length::Real) = TreeNode(-1, :birth, length, -1, collect(children))

function parse_treejson(json_trees)
    trees = map(json_trees) do json_tree
        # Fancy trick to parse Newick directly into TreeNode objects
        subtrees = replace(json_tree["newick"], ":" => "↓") |> Meta.parse |> eval

		# BEAST doesn't infer the length of the branch leading to the first birth event;
		# this means `tree` is really a tuple of the two root-most subtrees.
		# For the replay experiment, though, we trick BEAST into "knowing" the root sequence
		# by inducing a birth event very close to time 0, so that one of the root-most subtrees
		# is the root sequence. We don't include that in the final tree though.
		# Thus, here, we just need to add a root event node before the other subtree.
		first_child = (length(LeafTraversal(subtrees[1])) == 1) ? subtrees[2] : subtrees[1]
        root = TreeNode(0, :root, 0, -1, [first_child])

        # Fill in the names of ancestral nodes
        for node in PostOrderTraversal(root.children[1])
            if node.up.event != :root
                node.up.name = get_node_data(json_tree, node.name, "parent")
            end
        end

        # Correct `node.t` to be time since root, not branch length,
        # and fill in the sequences (into temporary storage, since the node state will be the corresponding affinity)
        for node in PreOrderTraversal(root.children[1])
            node.t = node.t + node.up.t
            node.info[:sequence] = get_node_data(json_tree, node.name, "state")
        end

		root_sequence = (length(LeafTraversal(subtrees[1])) == 1) ? get_node_data(json_tree, subtrees[1].name, "state") : get_node_data(json_tree, subtrees[2].name, "state")
        root.info[:sequence] = root_sequence

        # Add mutation events per the history
        # Remember that the history describes mutation leading TO this node
        present_time = maximum(leaf.t for leaf in LeafTraversal(root))

        for node in PreOrderTraversal(root.children[1])
            history = get_node_data(json_tree, node.name, "history")

            for mutation in history
                mutation["when"] = present_time - mutation["when"]
            end

            sort!(history, by = mutation -> mutation["when"], rev = true)

            current_node = node

            for mutation in history
                index = mutation["site"]
                current_sequence = current_node.info[:sequence]

                mutation_time = mutation["when"]

                @assert current_node.up.t < mutation_time < current_node.t
                @assert string(current_sequence[index]) == mutation["to_base"]

                new_sequence = current_sequence[1:index-1] * mutation["from_base"] * current_sequence[index+1:end]

                parent = current_node.up
                filter!(child -> child != current_node, parent.children)
                # Removing current_node.up is done in the TreeNode constructor in the next step

                new_node = TreeNode(node.name, :mutation, mutation["when"], -1, [current_node])
                new_node.info[:sequence] = new_sequence

                push!(parent.children, new_node)
                new_node.up = parent

                current_node = new_node
            end
        end

        root
    end

    # Compute the affinities for all sequences now, since it's fastest if we call the binary once with a batch
    all_nodes = [node for tree in trees for node in PreOrderTraversal(tree)]
    sequences = [node.info[:sequence] for node in all_nodes]

    affinities = pipeline(`get-affinity`; stdin=IOBuffer(join(sequences, "\n"))) |>
        (command -> read(command, String)) |>
        strip |>
        (text -> split(text, "\n")) |>
        (lines -> parse.(Float64, lines))

    for (affinity, node) in zip(affinities, all_nodes)
        node.state = affinity
    end

    return trees
end

json_trees = isempty(ARGS) ? JSON.parse(stdin) : JSON.parse(read(ARGS[1], String))
trees = parse_treejson(json_trees)
save_object("trees.jld2", trees)
