---
title: Playground
author: Thanasi Bakis
format:
    html:
        fig-format: svg
        fontsize: 1em
        theme:
            light: flatly
            dark: darkly
        toc: true
    pdf:
        fig-dpi: 300
echo: true
fig-align: center
highlight-style: github
warning: true
---

```{python}
import re
from collections import namedtuple
from ete3 import Tree
from gcdyn.phenotype import DMSPhenotype
from tqdm import tqdm
```

```{python}
phenotype = DMSPhenotype(
    1,
    1,
    336,
    "https://raw.githubusercontent.com/jbloomlab/Ab-CGGnaive_DMS/main/data/CGGnaive_sites.csv",
    "gcdyn/notebooks/tdms-linear.model",
    ["delta_log10_KD", "delta_expression", "delta_psr"],
    -10.43,
)
```

```{python}
SiteChange = namedtuple("SiteChange", ("when", "where", "from_base", "to_base"))

regex1 = r"\[&((?:(?:history_\d+|count)=\{[{}0-9ATGC.,E-]+\},?)+)\]"
regex2 = r"history_(\d+)=\{((?:\{[0-9.,ATGC]+\},?)+)\}"
regex3 = r"(\{[0-9.,ATGC]+\})+"

def extract_node_histories(tree_line):
    # `tree_line` contains the raw line from .history.trees
    # representing all the mutations along the entire tree

    node_histories = []

    for match1 in re.finditer(regex1, tree_line):
        site_changes = []

        for match2 in re.finditer(regex2, match1.group(1)):
            where = int(match2.group(1))

            for match3 in re.finditer(regex3, match2.group(2)):
                for site_change in match3.groups():
                    # TODO: double check that the order is "from,to"
                    when, from_base, to_base = site_change[1:-1].split(",")
                    site_changes.append(SiteChange(float(when), where, from_base, to_base))

        node_histories.append(site_changes)

    return node_histories
```

```{python}
global_name = "tenseqs"
trees = dict()

with open(f"beast_run/{global_name}.history.trees") as trees_file:
    for line in tqdm(trees_file):
        if not line.startswith("tree"):
            continue

        info, tree_line = line.split(" = ")

        sample_num = re.search(r"STATE_(\d+)", info).group(1)

        # ete3 can't read
        tree = Tree(
            re.sub(r'\[[a-zA-Z0-9=.\-,&{}_"]+\]', "", tree_line)
        )

        # TODO: is matching the sequences to postorder traversal correct?
        nodes = tree.traverse("postorder")
        sequences = map(
            lambda match: match.group(1),
            re.finditer(r'\[&states="([ATGC]+)"\]', tree_line),
        )

        node_histories = iter(extract_node_histories(tree_line))

        try:
            while True:
                node = next(nodes)
                sequence = next(sequences)

                node.add_features(
                    sequence = sequence,
                    kd = phenotype.calculate_KD([sequence])[0]
                )

                if not node.is_root():
                    node_history = next(node_histories)

                    node.add_features(history = node_history)

        except StopIteration:
            pass

        trees[int(sample_num)] = tree
```

```{python}
expanded_trees = dict()

def apply_site_change(sequence, site_change):
    index = site_change.where - 1
    assert sequence[index] == site_change.from_base

    return sequence[:index] + site_change.to_base + sequence[index + 1 :]

for i, tree in trees.items():
    tree2 = tree.copy()

    # Be sure to make a copy (list()) of the node sequence now,
    # because we are going to add nodes (that don't need traversing)
    for parent in list(tree2.traverse("levelorder")):

        # Note that node.history contains the mutations that led *to* this node,
        # not that follow this node
        # Note we use get_children() which makes a duplicate list of children,
        # since we'll be editing children in this loop
        for child in parent.get_children():

            child.detach()

            history = sorted(child.history,
                key = lambda site_change: site_change.when,
                reverse = True # remember time 0 is leaves, and time > 0 is distance to leaves
            )

            intermediate = parent
            previous_distance = 0

            for site_change in history[:-1]:
                new_sequence = apply_site_change(intermediate.sequence, site_change)
                intermediate = intermediate.add_child(dist = site_change.when - previous_distance)

                intermediate.add_features(
                    sequence = new_sequence,
                    kd = phenotype.calculate_KD([sequence])[0]
                )

            intermediate.add_child(child = child)
    
    expanded_trees[i] = tree2
```