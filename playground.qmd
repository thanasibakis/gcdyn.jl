---
title: Playground
author: Thanasi Bakis
format:
    html:
        fig-format: svg
        fontsize: 1em
        theme:
            light: flatly
            dark: darkly
        toc: true
    pdf:
        fig-dpi: 300
echo: true
fig-align: center
highlight-style: github
warning: true
---

```{python}
import re
from collections import namedtuple
from ete3 import Tree
from gcdyn.phenotype import DMSPhenotype
from tqdm import tqdm
```

```{python}
phenotype = DMSPhenotype(
    1,
    1,
    336,
    "https://raw.githubusercontent.com/jbloomlab/Ab-CGGnaive_DMS/main/data/CGGnaive_sites.csv",
    "gcdyn/notebooks/tdms-linear.model",
    ["delta_log10_KD", "delta_expression", "delta_psr"],
    -10.43,
)
```

```{python}
SiteChange = namedtuple("SiteChange", ("when", "where", "from_base", "to_base"))

regex1 = r"\[&((?:(?:history_\d+|count)=\{[{}0-9ATGC.,E-]+\},?)+)\]"
regex2 = r"history_(\d+)=\{((?:\{[0-9.,ATGC]+\},?)+)\}"
regex3 = r"(\{[0-9.,ATGC]+\})+"

def extract_node_histories(tree_line):
    # `tree_line` contains the raw line from .history.trees
    # representing all the mutations along the entire tree

    node_histories = []

    for match1 in re.finditer(regex1, tree_line):
        site_changes = []

        for match2 in re.finditer(regex2, match1.group(1)):
            where = int(match2.group(1))

            for match3 in re.finditer(regex3, match2.group(2)):
                for site_change in match3.groups():
                    # TODO: double check that the order is "from,to"
                    when, from_base, to_base = site_change[1:-1].split(",")
                    site_changes.append(SiteChange(float(when), where, from_base, to_base))

        node_histories.append(site_changes)

    return node_histories
```

```{python}
global_name = "tenseqs"
trees = dict()

with open(f"beast_run/{global_name}.history.trees") as trees_file:
    for line in tqdm(trees_file):
        if not line.startswith("tree"):
            continue

        info, tree_line = line.split(" = ")

        sample_num = re.search(r"STATE_(\d+)", info).group(1)

        # ete3 can't read
        tree = Tree(
            re.sub(r'\[[a-zA-Z0-9=.\-,&{}_"]+\]', "", tree_line)
        )

        # TODO: is matching the sequences to postorder traversal correct?
        nodes = tree.traverse("postorder")
        sequences = map(
            lambda match: match.group(1),
            re.finditer(r'\[&states="([ATGC]+)"\]', tree_line),
        )

        node_histories = iter(extract_node_histories(tree_line))

        try:
            while True:
                node = next(nodes)
                sequence = next(sequences)

                node.add_features(
                    sequence = sequence,
                    kd = phenotype.calculate_KD([sequence])[0]
                )

                if not node.is_root():
                    node_history = next(node_histories)

                    node.add_features(history = node_history)

        except StopIteration:
            pass

        trees[int(sample_num)] = tree
```

